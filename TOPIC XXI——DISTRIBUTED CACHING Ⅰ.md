# TOPIC XXI: DISTRIBUTED CACHING Ⅰ

## 0. 数据的使用
### 数据
* 应用程序 = 算法 + 数据
* 按使用方式和方式分类
    * 静态数据：一般不变
    * 准静态数据：变化频率很低
    * 中间状态数据：一些计算的可复用的中间数据（副本数据；副本丢了没事，可以从原始数据再计算）

* 适合缓存的数据的共同点：读写比高的热数据
    * `热数据`：使用频率高（性能需求，减轻数据库压力）
    * `“读写比”较大`：读频率 >> 写频率 

### 缓存
* 本质：系统内各级处理速度不匹配，`空间换时间`
    * 内存 ≈ CPU 和磁盘之间的缓存（原因：CPU 与磁盘的处理速度不一致）
    * CPU 与内存的处理速度不一致：出现 L1 & L2 Cache
    * 网络处理，数据库引擎的各种 Buffer
    * GUI 的 Double Buffer（用于性能优化）
* 好处：一个提升系统性能的简单有效方法
* 广义：加速业务处理、让业务更快访问的临时存放冗余数据
* 狭义：`内存缓存`（在分布式系统里缓存到内存的数据）

* 加载时机
    * 启动`全量加载`：全局有效，操作简单
        * 副作用：缓存数据量大，启动慢
    * `懒加载`：策略复杂
        1. `同步`使用加载：先看缓存，没有数据则从 DB 读取；读取的数据先放内存，然后返回给调用方。
        2. 延迟`异步`加载：从缓存获取数据，不管是否为空直接返回 --> 
        * `策略1——异步`（对数据一致性要求较高时）：缓存数据为空，发起一个异步加载的线程，负责`加载数据`。
        * `策略2——解耦`（查询和维护解耦，假设当前缓存与数据库一致）：异步线程负责维护缓存的数据，定期或根据条件触发更新。

* 有效性与数据同步
    * 为什么变动频率大、一致性要求高的数据不适合用缓存？————
        * 变化大 = 内存缓存数据和原始数据库数据之间`一直有差异`（导致缓存有效性不高）；
        * 一致性要求高 = 只有使用原始数据，甚至添加事务，才保险。
    * 缓存的有效性————
        * `读写比`：写操作导致数据变动，即维护成本（N:1）
        * `命中率`：命中缓存 = 缓存数据被使用 = 缓存数据有价值（一般要求90%+）
    * 引入缓存的必须指标（综合衡量）
        * 数据一致性：如果数据全放在内存中，数据库和内存之间的数据一致性会复杂
        * 性能
        * 成本：内存比磁盘贵很多

* 使用不当导致的问题
    * `系统预热 --> 启动慢` --> 系统不能快速应对故障宕机等问题
        * 稳定性工程中要求所有系统在分钟及时间内尽可能快地拉起，快速恢复到上一版本
    * `系统内存资源耗尽`
        * 只加入数据，不能清理旧数据（solution：内存清理 & 容量管理）
        * 旧数据处理不及时 / 不能有效识别无用数据


## 1. 本地缓存/远程缓存：42'45''
### 本地缓存
* 简单示例
    ```java
    public static final Map<String, Object> CACHE = new HashMap();
    CACHE.put("beijing", "100001");
    String cityCode = (String) CACHE.get("beijing");
    ```
    * 还缺少容量管理机制，缓存数据淘汰策略等

* in Hibernate / MyBatis
    * 分级
        * 一级缓存：session 级别（当前会话中有效）
        * 二级缓存：SessionFactory 级别（全局有效）
    * in Hibernate
        * 配置指定使用 EhCache 等
        * cache 的开启放在 SQL 语句中
    * in MyBatis
        * 配置指定使用 EhCache 等
        * cache 的开启放在对象和表对应的实体类配置中

* in Guava
    ```java
    Cache<String, String> cache = CacheBuilder.newBuilder().maximumSize(1024).expireAfterWrite(60, TimeUnit.SECONDS).weakValues().build();
    cache.put("word", "Hello Guava Cache");
    System.out.println(cache.getIfPresent("word"));
    ```
    * 使用：类似 map 
        * 其他功能：显式清除数据、统计缓存信息、移除事件的监听器、自动加载等。

* in Spring Cache 
    * 一种使用 cache 的方式，可以配合 EhCache,  Guava Cache, Redis 等底层使用
    * 好处
        * 基于注解和 AOP，使用方便
        * 可配置 Condition 和 SPEL 表达式语言（何时生效、何时使用等），灵活
        * 注：绕过 Spring，注解无效
    * 核心功能：@Cacheable, @CachePut, @CacheEvict
    * [参考](https://developer.ibm.com/zh/articles/os-cn-spring-cache/)

### 远程缓存
* 本地缓存的3个缺点
    * 在多个集群环境同步？————当集群规模增大，缓存的读写放大
        * 思路：不管部署几套服务，缓存只拉取一份，专人管理缓存
    * 在 JVM 中长期占用内存？————如果是堆内存，总是影响到 GC
        * 思路：不使用 JAVA 开发
    * 缓存数据的调度处理————影响执行业务的线程，抢占资源
    * solution: `集中处理缓存`
        * 缺点：多了一次网络开销

* 第一代解决方案：Redis / Memcached `缓存中间件`
    * Redis (Remote Dictionary Server)：支持网路、基于内存也支持持久化的日志型、key-value 存储系统
    * Memcached：开源高性能、分布式内存对象缓存系统
* 第二代解决方案：Hazelcast / Ignite `内存网格`
    * 内存网格：串起本地缓存和远程缓存，屏蔽网路差异，都当作本地缓存使用，一种基于内存的网络结构


## 2. 缓存策略/缓存常见问题：25'42''
### 缓存策略
* 缓存数据容量
    * 出发点：资源有限
    * 架构设计思考点：设计容量、使用容量、峰值
* 过期/清理/淘汰策略（淘汰历史缓存，让更有价值的数据进入缓存）
    * 按 FIFO / `LRU`（缓存热数据）   
    * 按`固定时间`过期（设置过期时间，清理失效缓存；存在不合理，固定时长的缓存无法感知数据的更新时间点、变化次数等；适用于`对一致性要求不高`的场景）
        * 例，买机票；读写比很大。买当日机票，购买人数多、信息变化较快；买x天后的机票，信息相对稳定。 
    * 按业务时间`加权`（细粒度优化）
        * 例，买机票。大多数都是买当日机票，缓存3分钟用于查询信息；买x天后的机票，缓存 (3+5x) 分钟。减轻查询接口调用压力（`结合场景`做成本的综合优化）。

### 缓存常见问题
* 缓存`穿透`
    * 描述：大量`并发`、查询`不存在的 key` --> 直接将压力穿透到数据库
    * 原因思考：返回为空，缓存无法判断“key 不存在”还是“key 查询到一个空值”。
    * 解决方法
        * 缓存`空值的 key`（业务语义上代表空值的 key；则第一次不存在也会被加载记录）。
        * Bloom 过滤 / RoaringBitmap（位操作），判断 key 是否存在。
        * 完全以缓存为准，无论是否存在，即刻返回（隔离缓存基于数据库的更新和缓存的查询）；使用`延迟异步加载`的“策略2——解耦：异步线程负责维护缓存的数据，定期或根据条件触发更新”。

* 缓存`击穿`
    * 描述：`某个具体的 key 失效`时，正好有大量并发请求访问该 key
    * 解决方法
        * key 的更新操作添加`全局互斥锁`（避免大量并发重复加载）。
        * 完全以缓存为准，使用`延迟异步加载`的“策略2——解耦：异步线程负责维护缓存的数据，定期或根据条件触发更新”。

* 缓存`雪崩`
    * 描述：当`某一时刻发生大规模的缓存失效`时，会有大量请求直接打到数据库，导致数据库压力过大甚至宕机
    * 思路：由于更新策略、数据热点、缓存服务宕机等原因，可能导致缓存数据在同一时间点大规模不可用，或都更新。因此需要更新策略在时间上合适（时间错开），数据要均匀分散（不要存在热点），缓存服务器要多台高可用。
    * 解决方法
        * 更新策略：在时间上做到`均匀`（时间差）。
        * 使用的`热数据尽量分散`到不同机器。
        * 多台机器做主从复制/多副本，实现`高可用`。
        * 实现`熔断限流`机制，对系统进行负载能力控制。


