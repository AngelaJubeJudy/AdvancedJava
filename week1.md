# Week 1: 2021-06-21 ~ 06-27
## 时长共计：641min = 10h 41min

## 0. 预习
### 环境准备
### 常用性能指标
### JVM 基础
### JAVA 字节码技术

# 第一课
## 1. 编程语言 JAVA：11'1''
* 面向对象，基于虚拟机，静态类型编译语言
* 有VM——JVM
* 有GC——内存管理器
* 有运行时——环境
* 跨平台——在各种OS上都可以运行
    * 字节码文件：分发到不同平台上；只要平台上有JRE，不需要再编译，即可方便快速地部署运行。
    * 文件系统中的`字节码文件`，通过进程加载起来，由VM中的`类加载器`将文件加载到VM内部，然后再转化为具体的对象。
    * 关键一：字节码文件。
    * 关键二：类加载器。
    * 关键三：VM中的内存管理。


## 2.JAVA 字节码技术：44'32''
### 简述
* Java 字节码文件：由单字节的指令组成；1 byte = 256 bits 操作码。
* 四类指令/操作码
    * `栈操作指令`（JVM是基于栈的操作）——不与JAVA直接对应
    * `程序流程控制指令`（逻辑控制）——与JAVA直接对应
    * `对象操作指令`（JAVA是面向对象的）——与JAVA直接对应
    * `算数运算&类型转换指令`——与JAVA直接对应
* 通过 `javac packageName/fileName.java` 编译后：得到和JAVA文件同名，但扩展名为`“.class”`的文件。
    * 查看编译好的class文件内部的字节码结构：
    ```bash
    javap -c packageName.fileName
    ```
    * 两部分：当前类的无参构造函数 + main方法
    * 指令举例；load指令将本地变量表中用到的变量加载到栈，计算完成后变量通过store指令出栈。
    * 指令前的数字表示“偏移量”，单位是字节。
    * 一行指令：由操作码和操作数共同组成
    * 查看编译好的class文件内部的字节码结构（`附带常量池等其他信息`）：
    ```bash
    javap -c -verbose packageName.fileName
    ```
    * JVM 运行时需要知道stack的深度、locals本地变量表的长度（从上一条的打印信息可以查看）。
    * major version = 52 意味着文件是由JDK8编译的，JDK版本向下兼容（从上一条的打印信息可以查看）。
    * 如要查看额外信息，在编译时多加一个参数：
    ```bash
    javac -g packageName.fileName
    ```
    之后使用javap查看编译文件时就会看到“LocalVariableTable”本地变量表。

### JVM 在运行时的状态
* JVM 是一个基于`栈`的计算机。
* 每个运行中的线程有一个独享的JVM Stack，存储Frame栈帧。
* 每一次方法调用，JVM会自动创建一个栈帧。
    * `栈帧 = 操作数栈 + 局部变量数组 + class引用`
    * class引用里包含了常量池。
    * 操作时：`常量`从常量池中拿，`变量`从本地变量表压到栈上，运行完写回本地变量表。操作数栈相当于CPU，运行所有指令。
* 所有的指令：可以转化为一个`长度为8的十六进制字节数组`。
* `算数运算&类型转换指令`：i——int, d——double, f——float, l——long；a——对象类型。
* 以上类型：对于VM的栈语言来说，整个类型被简化了。实际的变量类型远远超过以上几种。
* `程序流程控制指令`：if_icpmge, cmp = compare, ge = greater than and equals to, i = int; goto.
* 方法调用的指令：Invokestatic——调用静态方法，Invokespecial——调用构造函数，Invokevirtual——调用私有方法，Invokeinterface——通过接口引用调用方法，Invokedynamic——JDK7新增指令。


## 3. JVM 类加载器：33'45''
### 类加载器的重要性
* 实际场景的应用：关于调用类但找不到防范的异常的分析，在运行期把一个jar包或一个类加载到JVM里使用，等等。
* 作用于类的加载和卸载，作用体现在类的声明周期里。
* 类的生命周期 = 加载 + 验证 + 准备 + 解析 + 初始化 + 使用 + 卸载
* `类加载的过程 = 加载 + 验证 + 准备 + 解析 + 初始化`
* loading，加载：找有没有.class文件。
* verification，验证：格式 & 依赖 是否正确。
* preparation，准备：处理静态字段和方法表。
* resolution，解析：各种符号解析成对应的引用。
* initialization，初始化：构造器、静态变量赋值、静态代码块。
* 以上5个步骤进行完后类就是完整的可被使用的状态。
* 步骤234可以统称为“`链接`”阶段。 

### 类的加载时机：786
* 显示调用
    * JVM启动时，初始化`主类`（main方法作为应用入口，第一时间被加载到内存中）。
    * new的类
    * 调用静态方法的指令，初始化其所在类。
    * 调用静态字段的指令，初始化其所在类。
* 隐式调用
    * 初始化的`子类`的`父类`。
    * 初始化`实践类`的`接口类`（如果接口定义了default方法）。
    * 使用反射API对某个类进行反射调用，对具体要调用的类型初始化。
    * 初次调用 MethodHandle 方法指针时，初始化方法指针指向的方法所在的类。
* 不会初始化的时机
    * 通过子类引用父类的静态字段，只触发父类的初始化。
    * 定义对象数组（new完只是一个空引用）。
    * 常量（常量在编译时被写入常量池）。
    * 通过类名获取Class对象。
    * 通过Class.forName加载指定类，参数initialize=false时。
    * 通过ClassLoader默认的loadClass方法（加载，但不初始化）。

### 三类加载器
* BootstrapClassLoader 启动类加载器：JDK 最核心类。
* ExtClassLoader 扩展类加载器：上一个的补充，加载额外的类，如lib中的类。
    * 扩展类路径：存放共性地依赖的包
* AppClassLoader 应用类加载器：程序员自己写的类和依赖项。
* 加载器的特点
    * 双亲委托——首先委托父加载器去加载类 （父 BootstrapClassLoader ---> ExtClassLoader ---> AppClassLoader 子），避免重复加载。
    * 负责依赖——处理依赖。
    * 缓存加载——一个类只会被加载一次，避免重复加载。

### 系统自带的ClassLoader
* BootstrapClassLoader 在JVM内部，Oracle JDK和Open JDK中有方法可以拿到启动类加载器加载的URL：
```java
URL[] urla = sum.misc.Launcher.getBootstrapClassPath().getURLs();
```
* ExtClassLoader
```java
printClassloader("扩展类加载器", JvmClassLoaderPrintPath.class.getClassLoader().getParent());
```
* AppClassLoader），避免重复加载。
```java
printClassloader("应用类加载器", JvmClassLoaderPrintPath.class.getClassLoader());
```
* 说明：“JvmClassLoaderPrintPath”为当前类的名称。

### 自定义的ClassLoader
* extends ClassLoader
* 不同之处：无需“fileName.java”和“fileName.class”文件。
* 用途：类的动态加载，加密保护等等。
* 编译好的.class文件，可以看到你的代码具体是如何执行的。

### 添加引用类的方式
* 除了自定义 ClassLoader 加载之外
* 其他方式 
    * 类或jar包放到 JDK 的 lib/ext 下，或，-Djava.ext.dirs （在启动命令中添加的额外参数）。
    * java + -cp或-classpath 参数 + 全路径 ，或 class 文件放到当前路径。
    * 拿到当前执行类的ClassLoader，反射调用 addUrl 方法添加 Jar 或路径。


## 4. JVM 内存模型：18'1''
### 堆栈
* “堆栈”：堆内存 + 线程栈
* 原生类型的局部变量，都存储在当前线程的线程栈。
    * 线程栈之间的局部变量共享通过副本实现。（有“并发”相关问题）
    * 对象引用地址存在栈上。
* 堆内存：存储引用类型（即，对象）
    * 对象本身和对象关联的成员变量都在堆内存上；在栈上操作时操作的是引用地址。
    * “共享堆”
### JVM 内存整体结构：5个部分
* JAVA进程 = 运行时的JVM
* 调用栈：多个栈帧组成
    * 可能由多种方法组成：一个Thread对应一个线程栈/方法栈。
    * 资源的隔离性实现：每执行一个方法，就给当前方法创建一个栈帧Frame。
    * 字节码中有写栈帧大小；栈帧包括局部变量表、操作数栈、一些指针。
* 堆内存结构
    * 所有线程共享堆内存；GC负责创建、回收、销毁堆内存上的对象。
    * 年轻代 Young-Gen：Eden-Space（一般对象被分配的位置）, Survivor 0（GC算法中的2个存活区，任何时刻S0S1有一个是空的）, Survivor 1.
    * 老年代 Old-gen
* 非堆（本质还是heap）
    * 存放元数据、JVM运行时的其他数据、JIT产生的数据。
    * Metaspace
* JVM自身的继承等
* 堆外：JVM直接使用的计算机内存空间
### JMM
* JAVA内存模型和线程规范。
* 规定了`线程间`如何共享变量以及访问的同步和可靠。
* 实际应用中，规范了多线程下内存的使用，相同代码、不同JVM实现产生的结果一致。
* `冲突`：对同一个变量的操作有并发行为（读、写、同步操作、外部操作）。
    * 单个线程内部：对于局部变量的操作是`线程安全`的。——不属于JMM控制的范围
* 场景：多核多CPU


## 5. JVM 启动参数：30'38''
### 不同环境下的高效运行：JVM的可调参数
* “-”开头：标准参数，所有JVM实现都支持；稳定，向后兼容
* “-”开头：系统属性
* “-X”开头：非标准参数（支持，但不保证所有JVM实现都满足，且不保证向后兼容）
* “-XX”开头：非稳定参数（随时可能在下一版本取消），用于控制JVM的行为
### 类型
* 系统属性
    * 给系统提供环境变量，只影响当前进程
    * 应用：给一个进程传递数据的方式
* 运行模式（例，-server）
    * -server 模式：启动慢，但runtime性能和内存管理效率高；用于Web应用和服务端应用的生产环境部署。
    * -client 模式：启动快，但runtime性能和内存管理效率低；用于PC应用和客户端应用的开发调试。
    * -Xint 模式：解释模式，即直接运行JVM字节码；速度低10倍。
    * -Xcomp 模式：第一次使用字节码时编译为本地代码执行，再缓存；开销大，速度快。
    * -Xmixed 模式：混合模式，热点代码直接编译成本地机器码，冷代码解释执行字节码；平衡编译成本。
* 堆内存设置
    * Xmx：控制堆内，最大堆内存。
    * Xms：堆内存空间的初始大小；当Xmx和Xms配置不一致时，内存扩容会导致性能抖动，内存溢出。
    * Xmn：Young区大小。
    * Meta：默认不限制空间大小。
    * 堆外 DirectMemory（直接内存不受GC管理）
    * Xss：每个线程栈的字节数；影响栈的深度
    * 配置注意：JVM除了使用堆内内存外，还有一些非堆和对外内存，因此Xmx不可设置的过大，谨防OOM内存溢出。
    * 实际应用中可以把每个应用程序运行在VM或Docker里，资源隔离，不会互相抢占内存资源；指定 Xmx 为整个操作系统的60%-80%，留出余量。
* GC 设置（最多）   
    * 格式：-XX: +UseG1GC，加号表示开关，“-XX: +Use”后面接垃圾回收器的名称。
    * JAVA 11+支持使用ZGC，JAVA 12+ShenandoahGC.
    * `思考：各个版本的默认GC是什么？`
* 分析诊断
    * 保存犯罪现场，存内存快照。
    * 出现问题时用gdb调试当前进程。
* JavaAgent
    * JVM的黑科技：额外提供一个库，配置在命令行启动参数里。在加载所有的jar包和class文件前会先拉起agent库，对需要加载的jar包和类文件进行预处理（非侵入方式，不改动源文件），增强运行期的加载方式。


# 第二课
## 6. JDK 内置命令行工具：40'57''
### 常用命令
* java：JVM启动的入口
* javac：编译成.class文件
* javap：反编译.class文件 / 用字节码的方式查看
* jar：项目打包命令（可以用zip解压工具解压）
### 命令行工具：查看JVM运行状态
* jps / jinfo：查看`JAVA进程`
    * jps -mlv 详细信息
    * 查看单个进程：jinfo
    * 坑，不兼容：各个账号探查权限不同；不同JDK版本，使用某一版下的jps查看时信息也不全。
* jstat：查看JVM内部`GC相关`信息
    * 统计信息
    * 常用：-gc （GC相关的推内存信息，显示为字节数，单位是KB） 和 -gcutil （GC相关区域使用率，显示为百分比）
    * -gcutil内容：timestamp 用-t参数打印, S0, S1, E, O 老年代, M 元数据区, CCS 压缩类区, YGC 年轻代GC次数, YGCT 年轻代GC时间, FGC FullGC次数, FGCT, GCT 所有GC的时间总和. 
    * -gc：含使用量和容量信息，可以计算为使用率
* jmap：查看heap或class占用空间统计；打`快照`
    * 静态堆内存的配置和实际使用大小
    * 不同类型在堆内存上的实例数和占用字节数（直方图；可以查看什么占用空间较多，从而调整数据类型的使用，节省空间）
    * 堆内存`dump`编程一个二进制文件等文件（即转储文件）
* jstack：查看所有`线程`信息
    * 加pid查看
    * -l：长列表模式查看线程的锁
    * 在Mac和Linux上可以使用“kill -3 pid”打印线程信息
* jcmd：（一个整合了以上的命令）执行JVM相关分析命令
    * 新版：JDK8+版本
    * 综合了前几个命令
* jrunscirpt / jjs：运行脚本片段
    * jrunscirpt：直接执行脚本。可以模拟curl命令。，交互式
    * jjs：相当于shell


## 7. JDK 内置图形化工具：21'53''
* 更方便地分析JVM内部情况
### jconsole
* 支持本地和远程访问JAVA进程
* 可视化面板——监控当前的JVM使用情况，随时间的发展趋势
    * 概览，JVM的初步了解：堆内存使用量，类，线程，CPU占用率
    * 内存：不同区域可以单独查看
    * 线程：可以查看每一个线程的详情；支持检测死锁
    * 类：已加载，已卸载
    * VM概要
### jvisualvm
* jdk1.8.0之后需要去官网下载工具安装
* 强大功能：`抽样器Sampler`
* 类似的工具：VisualGC 插件，与IDE结合使用
### jmc：最强大！！！
* JAVA Mission Control
* 强大功能：`JAVA飞行记录器`，记录一个时间段内的所有JVM内部的变化
    * 较之前几个工具的优势：对原始监控数据的汇总加工分析，还可以分析代码帮助调优
    * 1.8.0.261之后的JDK版本不带此功能
    * MAC：swt库替换老的库，防止卡死




