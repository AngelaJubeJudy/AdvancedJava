# Week 1: 2021-06-21 ~ 06-27
## 时长共计：641min = 10h 41min
  
# 0. 预习
### 环境准备
### 常用性能指标
### JVM 基础
### JAVA 字节码技术

# 第一课：JVM
## 1. 编程语言 JAVA：11'1''
* 面向对象，基于虚拟机，静态类型编译语言
* 有VM——JVM
* 有GC——内存管理器
* 有运行时——环境
* 跨平台——在各种OS上都可以运行
    * 字节码文件：分发到不同平台上；只要平台上有JRE，不需要再编译，即可方便快速地部署运行。
    * 文件系统中的`字节码文件`，通过进程加载起来，由VM中的`类加载器`将文件加载到VM内部，然后再转化为具体的对象。
    * 关键一：字节码文件。
    * 关键二：类加载器。
    * 关键三：VM中的内存管理。


## 2.JAVA 字节码技术：44'32''
### 简述
* Java 字节码文件：由单字节的指令组成；1 byte = 256 bits 操作码。
* 四类指令/操作码
    * `栈操作指令`（JVM是基于栈的操作）——不与JAVA直接对应
    * `程序流程控制指令`（逻辑控制）——与JAVA直接对应
    * `对象操作指令`（JAVA是面向对象的）——与JAVA直接对应
    * `算数运算&类型转换指令`——与JAVA直接对应
* 通过 `javac packageName/fileName.java` 编译后：得到和JAVA文件同名，但扩展名为`“.class”`的文件。
    * 查看编译好的class文件内部的字节码结构：
    ```bash
    javap -c packageName.fileName
    ```
    * 两部分：当前类的无参构造函数 + main方法
    * 指令举例；load指令将本地变量表中用到的变量加载到栈，计算完成后变量通过store指令出栈。
    * 指令前的数字表示“偏移量”，单位是字节。
    * 一行指令：由操作码和操作数共同组成
    * 查看编译好的class文件内部的字节码结构（`附带常量池等其他信息`）：
    ```bash
    javap -c -verbose packageName.fileName
    ```
    * JVM 运行时需要知道stack的深度、locals本地变量表的长度（从上一条的打印信息可以查看）。
    * major version = 52 意味着文件是由JDK8编译的，JDK版本向下兼容（从上一条的打印信息可以查看）。
    * 如要查看额外信息，在编译时多加一个参数：
    ```bash
    javac -g packageName.fileName
    ```
    之后使用javap查看编译文件时就会看到“LocalVariableTable”本地变量表。

### JVM 在运行时的状态
* JVM 是一个基于`栈`的计算机。
* 每个运行中的线程有一个独享的JVM Stack，存储Frame栈帧。
* 每一次方法调用，JVM会自动创建一个栈帧。
    * `栈帧 = 操作数栈 + 局部变量数组 + class引用`
    * class引用里包含了常量池。
    * 操作时：`常量`从常量池中拿，`变量`从本地变量表压到栈上，运行完写回本地变量表。操作数栈相当于CPU，运行所有指令。
* 所有的指令：可以转化为一个`长度为8的十六进制字节数组`。
* `算数运算&类型转换指令`：i——int, d——double, f——float, l——long；a——对象类型。
* 以上类型：对于VM的栈语言来说，整个类型被简化了。实际的变量类型远远超过以上几种。
* `程序流程控制指令`：if_icpmge, cmp = compare, ge = greater than and equals to, i = int; goto.
* 方法调用的指令：Invokestatic——调用静态方法，Invokespecial——调用构造函数，Invokevirtual——调用私有方法，Invokeinterface——通过接口引用调用方法，Invokedynamic——JDK7新增指令。


## 3. JVM 类加载器：33'45''
### 类加载器的重要性
* 实际场景的应用：关于调用类但找不到防范的异常的分析，在运行期把一个jar包或一个类加载到JVM里使用，等等。
* 作用于类的加载和卸载，作用体现在类的声明周期里。
* 类的生命周期 = 加载 + 验证 + 准备 + 解析 + 初始化 + 使用 + 卸载
* `类加载的过程 = 加载 + 验证 + 准备 + 解析 + 初始化`
* loading，加载：找有没有.class文件。
* verification，验证：格式 & 依赖 是否正确。
* preparation，准备：处理静态字段和方法表。
* resolution，解析：各种符号解析成对应的引用。
* initialization，初始化：构造器、静态变量赋值、静态代码块。
* 以上5个步骤进行完后类就是完整的可被使用的状态。
* 步骤234可以统称为“`链接`”阶段。 

### 类的加载时机：786
* 显示调用
    * JVM启动时，初始化`主类`（main方法作为应用入口，第一时间被加载到内存中）。
    * new的类
    * 调用静态方法的指令，初始化其所在类。
    * 调用静态字段的指令，初始化其所在类。
* 隐式调用
    * 初始化的`子类`的`父类`。
    * 初始化`实践类`的`接口类`（如果接口定义了default方法）。
    * 使用反射API对某个类进行反射调用，对具体要调用的类型初始化。
    * 初次调用 MethodHandle 方法指针时，初始化方法指针指向的方法所在的类。
* 不会初始化的时机
    * 通过子类引用父类的静态字段，只触发父类的初始化。
    * 定义对象数组（new完只是一个空引用）。
    * 常量（常量在编译时被写入常量池）。
    * 通过类名获取Class对象。
    * 通过Class.forName加载指定类，参数initialize=false时。
    * 通过ClassLoader默认的loadClass方法（加载，但不初始化）。

### 三类加载器
* BootstrapClassLoader 启动类加载器：JDK 最核心类。
* ExtClassLoader 扩展类加载器：上一个的补充，加载额外的类，如lib中的类。
    * 扩展类路径：存放共性地依赖的包
* AppClassLoader 应用类加载器：程序员自己写的类和依赖项。
* 加载器的特点
    * 双亲委托——首先委托父加载器去加载类 （父 BootstrapClassLoader ---> ExtClassLoader ---> AppClassLoader 子），避免重复加载。
    * 负责依赖——处理依赖。
    * 缓存加载——一个类只会被加载一次，避免重复加载。

### 系统自带的ClassLoader
* BootstrapClassLoader 在JVM内部，Oracle JDK和Open JDK中有方法可以拿到启动类加载器加载的URL：
```java
URL[] urla = sum.misc.Launcher.getBootstrapClassPath().getURLs();
```
* ExtClassLoader
```java
printClassloader("扩展类加载器", JvmClassLoaderPrintPath.class.getClassLoader().getParent());
```
* AppClassLoader），避免重复加载。
```java
printClassloader("应用类加载器", JvmClassLoaderPrintPath.class.getClassLoader());
```
* 说明：“JvmClassLoaderPrintPath”为当前类的名称。

### 自定义的ClassLoader
* extends ClassLoader
* 不同之处：无需“fileName.java”和“fileName.class”文件。
* 用途：类的动态加载，加密保护等等。
* 编译好的.class文件，可以看到你的代码具体是如何执行的。

### 添加引用类的方式
* 除了自定义 ClassLoader 加载之外
* 其他方式 
    * 类或jar包放到 JDK 的 lib/ext 下，或，-Djava.ext.dirs （在启动命令中添加的额外参数）。
    * java + -cp或-classpath 参数 + 全路径 ，或 class 文件放到当前路径。
    * 拿到当前执行类的ClassLoader，反射调用 addUrl 方法添加 Jar 或路径。


## 4. JVM 内存模型：18'1''
### 堆栈
* “堆栈”：堆内存 + 线程栈
* 原生类型的局部变量，都存储在当前线程的线程栈。
    * 线程栈之间的局部变量共享通过副本实现。（有“并发”相关问题）
    * 对象引用地址存在栈上。
* 堆内存：存储引用类型（即，对象）
    * 对象本身和对象关联的成员变量都在堆内存上；在栈上操作时操作的是引用地址。
    * “共享堆”

### JVM 内存整体结构：5个部分
* JAVA进程 = 运行时的JVM
* 调用栈：多个栈帧组成
    * 可能由多种方法组成：一个Thread对应一个线程栈/方法栈。
    * 资源的隔离性实现：每执行一个方法，就给当前方法创建一个栈帧Frame。
    * 字节码中有写栈帧大小；栈帧包括局部变量表、操作数栈、一些指针。
* 堆内存结构
    * 所有线程共享堆内存；GC负责创建、回收、销毁堆内存上的对象。
    * 年轻代 Young-Gen：Eden-Space（一般对象被分配的位置）, Survivor 0（GC算法中的2个存活区，任何时刻S0S1有一个是空的）, Survivor 1.
    * 老年代 Old-gen
* 非堆（本质还是heap）
    * 存放元数据、JVM运行时的其他数据、JIT产生的数据。
    * Metaspace
* JVM自身的继承等
* 堆外：JVM直接使用的计算机内存空间

### JMM
* JAVA内存模型和线程规范。
* 规定了`线程间`如何共享变量以及访问的同步和可靠。
* 实际应用中，规范了多线程下内存的使用，相同代码、不同JVM实现产生的结果一致。
* `冲突`：对同一个变量的操作有并发行为（读、写、同步操作、外部操作）。
    * 单个线程内部：对于局部变量的操作是`线程安全`的。——不属于JMM控制的范围
* 场景：多核多CPU


## 5. JVM 启动参数：30'38''
### 不同环境下的高效运行：JVM的可调参数
* “-”开头：标准参数，所有JVM实现都支持；稳定，向后兼容
* “-”开头：系统属性
* “-X”开头：非标准参数（支持，但不保证所有JVM实现都满足，且不保证向后兼容）
* “-XX”开头：非稳定参数（随时可能在下一版本取消），用于控制JVM的行为

### 类型
* 系统属性
    * 给系统提供环境变量，只影响当前进程
    * 应用：给一个进程传递数据的方式
* 运行模式（例，-server）
    * -server 模式：启动慢，但runtime性能和内存管理效率高；用于Web应用和服务端应用的生产环境部署。
    * -client 模式：启动快，但runtime性能和内存管理效率低；用于PC应用和客户端应用的开发调试。
    * -Xint 模式：解释模式，即直接运行JVM字节码；速度低10倍。
    * -Xcomp 模式：第一次使用字节码时编译为本地代码执行，再缓存；开销大，速度快。
    * -Xmixed 模式：混合模式，热点代码直接编译成本地机器码，冷代码解释执行字节码；平衡编译成本。
* 堆内存设置
    * Xmx：控制堆内，最大堆内存。
    * Xms：堆内存空间的初始大小；当Xmx和Xms配置不一致时，内存扩容会导致性能抖动，内存溢出。
    * Xmn：Young区大小。
    * Meta：默认不限制空间大小。
    * 堆外 DirectMemory（直接内存不受GC管理）
    * Xss：每个线程栈的字节数；影响栈的深度
    * 配置注意：JVM除了使用堆内内存外，还有一些非堆和对外内存，因此Xmx不可设置的过大，谨防OOM内存溢出。
    * 实际应用中可以把每个应用程序运行在VM或Docker里，资源隔离，不会互相抢占内存资源；指定 Xmx 为整个操作系统的60%-80%，留出余量。
* GC 设置（最多）   
    * 格式：-XX: +UseG1GC，加号表示开关，“-XX: +Use”后面接垃圾回收器的名称。
    * JAVA 11+支持使用ZGC，JAVA 12+ShenandoahGC.
    * `思考：各个版本的默认GC是什么？`
* 分析诊断
    * 保存犯罪现场，存内存快照。
    * 出现问题时用gdb调试当前进程。
* JavaAgent
    * JVM的黑科技：额外提供一个库，配置在命令行启动参数里。在加载所有的jar包和class文件前会先拉起agent库，对需要加载的jar包和类文件进行预处理（非侵入方式，不改动源文件），增强运行期的加载方式。


# 第二课：JDK
## 6. JDK 内置命令行工具：40'57''
### 常用命令
* java：JVM启动的入口
* javac：编译成.class文件
* javap：反编译.class文件 / 用字节码的方式查看
* jar：项目打包命令（可以用zip解压工具解压）

### 命令行工具：查看JVM运行状态
* jps / jinfo：查看`JAVA进程`
    * jps -mlv 详细信息
    * 查看单个进程：jinfo
    * 坑，不兼容：各个账号探查权限不同；不同JDK版本，使用某一版下的jps查看时信息也不全。
* jstat：查看JVM内部`GC相关`信息
    * 统计信息
    * 常用：-gc （GC相关的推内存信息，显示为字节数，单位是KB） 和 -gcutil （GC相关区域使用率，显示为百分比）
    * -gcutil内容：timestamp 用-t参数打印, S0, S1, E, O 老年代, M 元数据区, CCS 压缩类区, YGC 年轻代GC次数, YGCT 年轻代GC时间, FGC FullGC次数, FGCT, GCT 所有GC的时间总和. 
    * -gc：含使用量和容量信息，可以计算为使用率
* jmap：查看heap或class占用空间统计；打`快照`
    * 静态堆内存的配置和实际使用大小
    * 不同类型在堆内存上的实例数和占用字节数（直方图；可以查看什么占用空间较多，从而调整数据类型的使用，节省空间）
    * 堆内存`dump`编程一个二进制文件等文件（即转储文件）
* jstack：查看所有`线程`信息
    * 加pid查看
    * -l：长列表模式查看线程的锁
    * 在Mac和Linux上可以使用“kill -3 pid”打印线程信息
* jcmd：（一个整合了以上的命令）执行JVM相关分析命令
    * 新版：JDK8+版本
    * 综合了前几个命令
* jrunscirpt / jjs：运行脚本片段
    * jrunscirpt：直接执行脚本。可以模拟curl命令。，交互式
    * jjs：相当于shell


## 7. JDK 内置图形化工具：21'53''
* 更方便地分析JVM内部情况
### jconsole
* 支持本地和远程访问JAVA进程
* 可视化面板——监控当前的JVM使用情况，随时间的发展趋势
    * 概览，JVM的初步了解：堆内存使用量，类，线程，CPU占用率
    * 内存：不同区域可以单独查看
    * 线程：可以查看每一个线程的详情；支持检测死锁
    * 类：已加载，已卸载
    * VM概要

### jvisualvm
* jdk1.8.0之后需要去官网下载工具安装
* 强大功能：`抽样器Sampler`
* 类似的工具：VisualGC 插件，与IDE结合使用

### jmc：最强大！！！
* JAVA Mission Control
* 强大功能：`JAVA飞行记录器`，记录一个时间段内的所有JVM内部的变化
    * 较之前几个工具的优势：对原始监控数据的汇总加工分析，还可以分析代码帮助调优
    * 1.8.0.261之后的JDK版本不带此功能
    * MAC：swt库替换老的库，防止卡死


# 第三课：GC
## 8. GC 的背景与一般原理：23'45''
* 为什么JVM上有GC？
    * 内存资源的稀缺性（相对于一直有的CPU资源更加稀缺）

### GC：内存控制管理器
* solution 1：`引用计数`
    * 简单的垃圾回收算法（一般有效）
    * 引用计数决定了当前仓库是否有用
    * 原理：引用计数 = 0，无人使用，可被回收
    * 实际：仓库之间也存在引用关系（导致多个对象之间形成引用环，引用计数不会=0，类似死锁；最终导致内存泄漏，随时间推移导致内存溢出、程序崩溃）
* solution 2：`引用跟踪——Mark and Sweep “标记清除算法”`
    * 从根对象出发，扫描所有可达对象，组成集合，可达对象不能被回收；其他不可达的可被回收/清除。
    * 并行 GC 和 CMS GC 的基本原理！！！
    * 优势：解决引用计数的循环依赖问题；只扫描少量存活对象。
    * mark 可达对象，sweep 不可达对象（清除 / 压缩=内存整理）
    * Q：对象一直在动态增减，如何保证标记和清除的正确性？
    * A：`STW, Stop The World`——在垃圾回收的那个时间点，让`当前 JVM 内部的所有线程暂停`。也叫 JVM 的 GC 暂停。时间越短越好，发生频率越低越好。

### 分代假设
* 堆内存分区：`年轻代 Young Generation，老年代 Old Generation`
    * 长期存活的对象：老年代
    * 新对象的创建：年轻代————新生代 + S0 + S1
    * 新对象的创建：先分配在`Eden区`，标记阶段Eden区存活的对象会被`复制`到存活区S0（S0和S1其中之一）。当Eden区再次要满时，把Eden区和S0里存活的对象复制到S1，然后`清除`Eden区和S0里剩余的对象（包括：不可达+可达但已经被复制到了S1区）。下一个使用周期，Eden区和S1区。
    * 两个特点：Eden区、S0和S1只有两个区一直有数据；垃圾回收时，绝大多数对象都会被清除，只有`少量存活`（进行mark）。
    * `复制算法 Mark-Copy`————因为有空余空间，Eden区、S0和S1只有两个区一直有数据，S0和S1有一个叫“from”，另一个叫“to”.
    * `移动算法 Mark-Sweep-Compact`————老年代没有继续分区。
    * 对象存活过一定的GC周期后，被移动到老年代。`老年代默认都是存活对象。`
    * 老年代空间整理方法：复制老年代中所有存活对象，从空间开始的地方一次存放。即“内存的碎片整理”。
* 可作为 `GC Roots` 的对象
    * 当前正在执行的方法里的局部变量和输入参数（∵ 方法执行完之前一直有效）
    * 活动线程本身（∵ 当前的活动线程数是固定且有限的）
    * 类的静态字段（∵ 全局有效）
    * JNI 引用
    * 特点：扫描根对象速度很快（∵ 当前的活动线程数、方法数是固定且有限的，类的静态字段、JNI 引用的数量较少）
    * 基于以上特点：GC 算法在增加堆内存时，不会影响 GC 标记阶段产生的暂停时间。


## 9. 串行GC / 并行GC：10'25''

### 串行 GC
* 通过 JVM 参数 `“-XX:+UseSerialGC”` 来配置
* 串行 GC 与堆内存————`单线程`的垃圾回收器
    * 年轻代：mark-copy 算法
    * 老年代: mark-sweep-compact 算法
    * GC 期间，不管处理哪个区，所有的应用程序都 STW ==> 使用效率不高。
    * 对年轻代的改进：参数 `“-XX:+UserParNewGC”` 可以对年轻代进行`并行`的GC（和 CMS GC 配合使用）。
* 适用场景：堆内存较小的 JVM，且是单核 CPU 时比较有用。

### 并行 GC
* 通过 JVM 参数 `“-XX:+UseParallelGC”, “-XX:+UseParallelOldGC”, “-XX:+UseParallelGC -XX:+UseParallelOldGC”` 来配置（当并行 GC 不是默认时）
* 串行 GC 与堆内存————`线程数可指定`的垃圾回收器
    * 年轻代：mark-copy 算法
    * 老年代: mark-sweep-compact 算法
    * 指定线程：参数 `“-XX:+ParallelGCThreads=N”`，不指定时默认为 `CPU 核心数`
* 适用场景：多核服务器
* 主要目标：增加整个系统提供的吞吐量
    * 设计一：GC 期间，所有 CPU 的资源都用来并行地进行垃圾回收（一定时间内STW时间更短；其他时间段 CPU 资源专注于业务处理）
    * 设计二：2个 GC 周期的间隔期内无 GC 线程运行，无系统资源的额外消耗。
* 注：吞吐量最优 ！= GC 暂停时间最短，因此`并行 GC 的单次 GC 暂停时间较长`。
* 注：JDK 6\7\8 默认为并行 GC，从 JDK9 以后的版本都是 G1.


## 10. CMS GC： 21'7''
### Mostly `Concurrent` Mark and Sweep Garbage Collector
* 通过 JVM 参数 `“-XX:+UseConcMarkSweepGC”` 来配置
* CMS GC 与堆内存
    * 年轻代：STW方式的 mark-copy 算法 ———— 参数 `“-XX:+UserParNewGC”` 可以对年轻代进行`并行`的GC
    * 老年代: mark-sweep 算法（不压缩）
* 特点：避免老年代 GC 时暂停时间过长；大部分时间GC线程和业务线程可以一起并发执行
    * 老年代标记清除完之后，不做内存碎片整理；改用索引（`free-list 技术`），在其上记录当前所有可用的内存空间位置
    * “mark-and-sweep” 阶段不直接全程的STW，不做所有业务线程的 GC 暂停（业务线程的连续性）
* 主要目标：Concurrent
    * 设计：GC 期间，默认有1/4 CPU 核心数的资源用来并行地进行垃圾回收
* 两点注意
    * 少量的GC线程和大量的业务线程会竞争CPU资源
    * 老年代GC的过程中还会有少量的年轻代Minor GC
* JAVA 8 上 CMS 的最大 Young 区大小与 GC 线程数有关：332.8M = 64M * GC线程数 * 13/10

### 并行 vs 并发
* 相同点
    * 可以使用多个线程进行 GC
* 不同点
    * 并行————使用所有 CPU 的核心线程数
    * 并发————做 GC 的线程和业务线程大多数时候可以同时运行

### CMS GC 执行的6个阶段
* 阶段1和4非并发，需要做全线STW
* 阶段2、3、5、6：并发
#### 1. Initial Mark
* 三件事
    * 标记所有根对象  
    * 标记根对象直接引用的对象 
    * 标记年轻代指向老年代的对象（JVM内部有一个集合 RSet 用于记录跨代的对象引用）
* 本阶段：`精确`标记对象
#### 2. Concurrent Mark
* 从上一个阶段已标记对象向下找引用，遍历整个老年代所有堆内存的对象
* 注：内存里的关系时刻在`变化`（∵ 没有全线STW），且GC线程与业务线程并发执行，标记随时可能变化
* 本阶段：标记不精确
#### 3. Concurrent Preclean 并发预清理
* 处理上一阶段可能遇到的关系变化情况：识别变化区域，“脏区”
    * `Card Marking 卡片标记`：JVM 用卡片的方式将变化区域标记
* 本阶段：标记不精确
#### 4. Final Remark 
* 处理上一阶段也可能遇到的关系变化情况：此阶段进行STW
* 完成老年代中所有存活对象的标记
* 本阶段：标记`精确`
* 注：CMS GC 会在 Young区对象较少时做Final Remark，避免连续触发多次STW
#### 5. Concurrent Sweep 
* 并发清理不再使用的垃圾对象
#### 6. Concurrent Reset
* 重置JVM内部CMS相关的数据和状态，为下一次 GC 循环做准备
#### 优点：GC 过程多阶段，大多数时候并发，短时间STW，对业务影响最小

#### 缺点：内存不连续，老年代标记完无压缩/碎片整理，导致GC时间不可控


## 11. G1 GC： 22'16''
### Garbage First GC 
* CMS GC 的重大改造：“启发式算法”
* 优先清理堆内存中垃圾最多的区（在并发阶段估算每一region的垃圾数量），提高回收效率  
* 设计目标：进一步控制 STW 的时间，且时间可预期、可配置 
    * JVM 参数 `“-XX:_UseG1GC -XX:MaxGCPauseMillis=50”`（默认200毫秒）
    * 吞吐量和延迟之间的平衡
* G1 GC 与堆内存
    * `Region`（不再分年轻代和老年代）：每次只回收一部分小区间，Collection Set
    * 每个 Region 的作用随内存使用需求改变（Eden / Survivor / Old）：更灵活
    * 以`增量`方式处理垃圾
    * STW 时：回收所有标记为年轻代的region以及一部分标记为Old的region

### 配置参数
参数 | 类型 | 占Java Heap的大小 | 备注
---|---|---|---
G1NewSizePercent | -XX | 5% | `初始`年轻代
G1MaxNewSizePercent | -XX | 60% | `最大`年轻代
G1HeapRegionSize | -XX | -- | 单位：MB，默认是堆内存的1/2000；取值：1、2、4、8、16、32；设置较大数值可以允许大对象进入region 
ConcGCThreads | -XX | -- | `与Java应用一起执行的GC线程数量`，默认是Java线程的1/4（与CMS GC一样）；减小数值=提高GC并行效率+提高系统内部吞吐量，如果垃圾过多不建议减小数值，否则垃圾处理很慢
`+InitiatingHeapOccupancyPercent` | -XX | （默认）45% | IHOP，G1内部并行回收循环启动的阈值（当老年代的使用率超过45%，JVM启动GC）
`G1HeapWastePercent` | -XX | 5% | G1停止回收的最小内存大小
GCTimeRatio | -XX | -- | 花在应用线程和GC线程上的时间比率，默认是9（并行GC默认是99）；GC的工作时间计算 = 100 / (1 + GCTimeRatio).
MaxGCPauseMillis | -XX | -- | GC运行平稳后，能够控制每次GC时间不超过这个`预期`数值；默认200

### G1 GC 的注意事项
* 缺点：某些情况下，G1 GC 触发 `FullGC`，`退化`成串行GC，导致单次GC时间的整体延时上升，影响正常的业务
* 原因一：并发模式失败
    * G1启动标记周期时，垃圾太多，老年代已被填满，此时G1GC会放弃标记工作，退化
    * 解决：增加堆内存大小 / 调整GC周期 / 增加GC周期
* 原因二：晋升Old失败
    * 解决：增加G1 GC保留内存（用于“复制”）百分比 / 减少IHOP（提前启动标记周期） / 增加并发GC线程数
* 原因三：巨型对象分配失败
    * 解决：增加堆内存 / 调整region大小


## 12. ZGC / Shenandoah GC：25'23''
* JAVA 11/12里的高级GC策略
### Java 11: ZGC
* 通过 JVM 参数 `“-XX:+UnlockExperimentalVMOptions -XX:+UseZGC”` 来配置
    * 未引入的Java版本需要开启实验性开关；内置了ZGC的无需该JVM参数
* 特点
    * 暂停时间非常短，即`“低延迟”`：控制在10ms内
    * 可以支持`大范围`的堆内存（小空间和超大堆内存都可以）
    * 因为GC延迟短，整体系统的吞吐量就会下降（但与G1相比下降不超过15%）

### Java 12: Shenandoah GC
* 通过 JVM 参数 `“-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahZGC”` 来配置
    * 未引入的Java版本需要解锁实验性开关 
* 极大改善JVM内部的GC暂停时间
    * 无论是Young区还是Old区，绝大多数GC线程都可以和业务线程并发执行

### GC 算法总结
* STW 时长（大->小）：SerialGC最大，ParallelGC较大，CMS GC降低单次GC时间，G1做增量的整理与回收（进一步降低单次GC时间），ZGC超低延迟，Shenandoah GC是G1的改进版（和ZGC类似）
* 吞吐量：ParallelGC > CMS GC, G1 > ZGC
* 并行：
    * ParNew在串行GC基础上改造，和CMS GC配套使用
    * Parallel Scavenge 年轻代，Parallel Old 老年代：多线程GC，高吞吐
* 发展趋势
    * 串行 --> 并行：利用多核CPU优势
    * 并行 --> 并发：追求低延迟
    * CMS --> G1：降低单次GC暂停时间
    * G1 --> ZGC：低/无停顿GC
* 业务选择
    * serial + serial old：年轻代和老年代都串行；单线程，低延迟；桌面系统
    * ParNew + CMS：多线程，相对低延迟
    * Parallel Scavenge + Parallel Scavenge Old：多线程，高吞吐；web系统
* 脱离场景谈性能都是耍流氓

