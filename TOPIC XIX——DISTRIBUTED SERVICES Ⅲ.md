# TOPIC XIX: DISTRIBUTED SERVICES Ⅲ——深入分布式服务化

## 1. 分布式服务治理/配置/注册/元数据中心：42'9''
### 分布式服务治理
#### 从 RPC 到分布式服务化
* 大规模`分布式业务场景`里的非功能性需求考虑
    * 多个相同服务如何管理？==> 集群/分组/版本 ==> 分布式与集群
    * （大量服务）服务的注册发现机制 ==> 注册中心/注册/发现 
    * 如何做到负载均衡、路由等集群功能？==> 路由/负载均衡
    * （大流量）请求量较大时，熔断、限流等治理能力 ==> 过滤/流控/过载保护 
    * 心跳、重试等策略
    * （非功能性需求）高可用、监控、性能等
* 思考：其他考虑点

* RPC 与分布式服务化的区别
    * RPC：技术概念，开发级别的概念
        * 在技术之上可以考虑性能优化，以及使用 Spring Boot 等封装，使之更加易用。
    * 分布式服务化：服务是业务语义；业务与系统的集成 
        * 分布式服务化框架角度：功能性需求 + 非功能性需求
        * 另：如何设计分布式场景下的业务服务？
        * 接口≠服务，只是服务的描述

#### 分布式服务化 vs SOA/ESB
* SOA/ESB
    * 架构
        * n个服务调用者---ESB（中心节点）---m个服务提供者
    * 代理调用，直接增强：服务汇聚到 ESB 
        * 暴露和调用
        * 增强和中介
        * 统计和监控
* 分布式服务化
    * `直连调用，侧边增强`：配置与注册发现
        * 直连调用：服务消费者直接调用服务提供者，比ESB减少了一个网络调用
        * 侧边：配置中心，注册中心；异步交互，不影响业务处理过程中的调用
    * 新组件：配置中心，注册中心
    * 分布式服务化关于有 RPC 之上的增强能力（原 ESB 实现的增强被拆分）
        * `有状态`部分————放到XX中心（保存状态，即需要持久化的数据）
        * `无状态`部分————放到业务侧（框架和配置部分[框架治理模块，RPC模块]，作为依赖模块，尽量减少业务侵入性）

### 配置/注册/元数据中心
* 比较
    * 相同点：都需要保存和读取数据/`状态`，变更通知
    * 不同点    
        * 配置中心：`全局`非业务参数
        * 注册中心：`运行期`临时状态
        * 元数据中心：业务模型

* 配置中心：ConfigCenter
    * 管理系统需要的启动/运行时的配置参数信息；`与业务无关`
    * Q1：大规模集群下的配置信息管理、批量更新问题
    * Q2：大公司/金融行业，要求开发、测试、运维环境的物理分离
    * Q3：运行期的开关控制
    * 实现配置中心的主流基座：Zookeeper, etcd, Nacos, Apollo 等。

* 注册中心：RegistryCenter
    * 管理系统的服务注册，提供发现和协调能力；中间信息，动态信息，管理实例和状态
    * 让消费者动态获取生产者集群的状态变化
        * 常见方式：（HTTP场景）hello.html，DNS，VIP；（RPC）主动报告，节点间心跳探活
        * 重要的`全局状态`信息：广泛应用于集群管控、分布式服务治理等
            * 服务提供者将自己注册到注册中心的临时节点 
            * 或，超时机制模拟临时节点

* 元数据中心：MetadataCenter
    * 管理各节点使用的元数据信息；`业务相关`，业务模型
    * 显式定义所有业务服务的模型

* 如何实现XX中心？
    * 核心要素
        * 1. 需要有`存取数据`的能力（特别是临时数据）
        * 2. 需要有数据变化的实时通知机制，`全量`或`增量`
    * 实现XX中心的主流基座：一般用 `namespace` 的概念，在顶层隔离不同环境
        * Zookeeper 没有 namespace 的概念，一般用根目录下第一个节点作为 namespace/group
    * Model 模型 + Center Repository 基座适配；例，某开源软件的设计，
        * 配置中心：ZookeeperCenterRepository, EtcdCenterRepository, ApolloCenterRepository, NacosCenterRepository
        * 注册中心：ZookeeperCenterRepository, EtcdCenterRepository, EurekaCenterRepository, ConsultCenterRepository, NacosCenterRepository
        * 元数据中心：ZookeeperCenterRepository, EtcdCenterRepository


## 2. 服务的注册与发现/集群与路由/过滤与监控：36'37''
### 服务的注册与发现
* 服务注册  
    * 发起方：服务提供者
    * 启动时，将自己注册到注册中心的`临时节点`
    * 停止/宕机时，临时节点消失（准实时自动通知订阅了服务的消费者）
    * 注册的`数据格式`
        * 节点 `key`：代表当前服务 / 服务+版本。
        * 多个`子节点（临时节点）`：每一个代表一个提供者的描述信息。
* 服务发现
    * 服务消费者启动时：
        * 从注册中心代表服务的`主节点（key）`拿到多个代表提供者的`临时节点列表`，并`本地缓存`（平衡调用性能；列表变化频率不高）。
        * 根据 router 和 loadbalance 算法，从其中的某一个节点执行调用。
        * 若可用的提供者集合发生变化，注册中心通知消费者刷新本地缓存的列表。
    * 例：Zookeeper 可以用 curator 作为客户端操作。

### 服务的集群与路由
* 场景：服务集群中，多个服务提供者提供了相同的服务
* 方案：完全相同能力的多个服务协同工作、分摊流量压力
    * `服务路由（Service Route）`
        * 参考网关的路由实现
        * 对当前的服务提供者列表做一次过滤，返回子集（逻辑隔离，`运行期的动态分组`）
        * 例：基于 IP 段的过滤；服务都带上 tag，用 tag 匹配当前调用范围。
    * `服务负载均衡（Service LoadBalance）`
        * 参考 Nginx 的负载均衡
        * 分散调用压力
        * 多个不同策略：原理不同，目的基本一致（尽量均匀）
            * Random：带权重，Dubbo 的默认策略
            * RoundRobin 轮询
            * LeastActive 最少活跃（处理快的多分配调用）
            * ConsistentHashLoadBalance：一致性哈希，同样参数请求到一个服务提供者

### 服务的过滤与监控
* 服务过滤
    * `计算机中任何复杂处理的抽象：“管道+过滤器”模式（Channel + Filter）`
        * 超级 Bug 机制：自定义 Filter、Filter 链，对业务处理过程进行干扰（差异性的处理）
    * 用途：
        * 实现额外的增强处理
        * 中断当前处理流程，返回特定数据

* 服务流控（Flow Control）
    * 基于过滤实现
    * 出发点：输入请求 > 处理能力
        * 系统容量有限
    * “稳定性工程”
        * 系统会故障是正常现象：（最佳选择）保持部分服务能力
        * 响应式编程里的回弹性（Resilient）
    * 3个级别（适用场景逐渐严重）
        * 限流————内部线程数，外部调用数或数据量
            * 内部处理业务的线程数
            * 更细粒度：平台全局调用次数 ---> 不同级别用户调用次数 ---> 不同权重的接口调用次数 ---> 单位时间内调用的数据量
            * 本质：限制资源的使用次数/量。
        * 服务降级————只保留核心逻辑
            * 非必要的调用：短暂不可用 / 延后处理
        * 过载保护————系统短时间不提供新的业务处理服务，积压处理完后再恢复输入请求


